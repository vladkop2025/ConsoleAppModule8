using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp8
{
    class Program
    {
        static void Main(string[] args)
        {
            //Модуль 8.Работа с файлами - 8.3. Классы для работы с файлами
            /*
            Для работы с файлами в пространстве имен System.IO служат классы File и FileInfo. 

            Их функционал позволяет выполнять с файлами следующие действия: 

                Создавать и удалять;
                Копировать и перемещать;
                Открывать и переименовывать;
                Соединять два файла в один;
                Изменять атрибуты файла для файловой системы.

            Классы File и  FileInfo рекомендуется применять  для общих операций (как перечислены выше), которые можно осуществлять  с файлами всех типов.

            Если же необходима работа со строками и отдельными символами в текстовых файлах, предусмотрен класс StreamWriter (его рассмотрим чуть позже).

            File и FileInfo — схожие по назначению классы, но между ними есть некоторые различия. Так, все методы класса File — статические, поэтому при файловых операциях с ним не нужно создавать объект. Все его методы требуют указания пути, то есть адресной ссылки внутри файловой системы.

            Таким образом, File стоит использовать в большинстве случаев, когда файловая операция — одиночная.

            Основные методы  класса File:  
            
                File.Create: создает файл;
                File.Delete: удаляет файл;
                File.Copy: копирует файл;
                File.Move: перемещает файл;
                File.Exist(path): проверяет существование файла.


              Если необходимо выполнять много действий с одним файлом, то удобнее создать один раз объект класса FileInfo и работать через него.

            Этот класс обладает более широким функционалом. Кроме аналогичных методов класса File, объект FileInfo имеет ряд полезных свойств:

                Length: получить размер файла;
                Directory: получить ссылку на каталог (DirectoryInfo), в котором файл расположен;
                DirectoryName: получить путь к родительскому каталогу;
                Exist: проверить существование файла;
                Extension: получить расширение файла;
                Name и FullName: получить имя и полное имя соответственно.

            Теперь рассмотрим на примере.

            Допустим, нам нужно создать файл и записать в него информацию, в коде выполним следующие действия: 

            Проверим существование файла
            Если не существует, создадим его и запишем строку.
            Откроем файл и прочитаем ранее записанную строку.
            Здесь воспользуемся классом File, так как задача одиночная

                string filePath = @"C:\source\Students.txt"; // Укажем путь 
                if (!File.Exists(filePath)) // Проверим, существует ли файл по данному пути
                {
                    //   Если не существует - создаём и записываем в строку
                    using (StreamWriter sw = File.CreateText(filePath))  // Конструкция Using (будет рассмотрена в последующих юнитах)
                    {
                        sw.WriteLine("Олег");
                        sw.WriteLine("Дмитрий");
                        sw.WriteLine("Иван");
                    }
                }
                // Откроем файл и прочитаем его содержимое
                using (StreamReader sr = File.OpenText(filePath))
                {
                    string str = "";
                    while ((str = sr.ReadLine()) != null) // Пока не кончатся строки - считываем из файла по одной и выводим в консоль
                    {
                        Console.WriteLine(str);
                    }
                }

            После выполнения программы получаем примерно следующий вывод на консоль: 

                Олег
                Дмитрий
                Иван
                       
            При этом в директории C:\source\ у нас должен был появиться новый список с именами студентов.

            Задание 8.3.1
            Исходный код программы — ещё один отличный пример текстового файла. 

            Напишите программу, которая выводит свой собственный исходный код в консоль.

            string filePath = @"C:\source\repos\ConsoleApp8\ConsoleApp8\Program.cs"; // Укажем путь

            // Откроем файл и прочитаем его содержимое
            using (StreamReader sr = File.OpenText(filePath))
            {
                string str = "";
                while ((str = sr.ReadLine()) != null)
                    Console.WriteLine(str);
            }

            Далее рассмотрим пример аналогичной задачи, где после операций чтения/записи в файл нам необходимо работать с ним в дальнейшем. 
            Для этого используем функционал класса FileInfo.

            Мы создаем временный файл и пишем в него 3 строки с именами. Далее построчно читаем из него и выводим на консоль. И, наконец, 
            используя уже имеющийся объект класса FileInfo, копируем информацию в новый файл и удаляем старый.

            string tempFile = Path.GetTempFileName(); // используем генерацию имени файла.
            var fileInfo = new FileInfo(tempFile); // Создаем объект класса FileInfo.

            //Создаем файл и записываем в него.
            using (StreamWriter sw = fileInfo.CreateText())
            {
                sw.WriteLine("Игорь");
                sw.WriteLine("Андрей");
                sw.WriteLine("Сергей");
            }

            //Открываем файл и читаем из него.
            using (StreamReader sr = fileInfo.OpenText())
            {
                string str = "";
                while ((str = sr.ReadLine()) != null)
                {
                    Console.WriteLine(str);
                }
            }

            try
            {
                string tempFile2 = Path.GetTempFileName();
                var fileInfo2 = new FileInfo(tempFile2);

                // Убедимся, что файл назначения точно отсутствует
                fileInfo2.Delete();

                // Копируем информацию
                fileInfo.CopyTo(tempFile2);
                Console.WriteLine($"{tempFile} скопирован в файл {tempFile2}.");
                //Удаляем ранее созданный файл.
                fileInfo.Delete();
                Console.WriteLine($"{tempFile} удален.");
            }
            catch (Exception e)
            {
                Console.WriteLine($"Ошибка: {e}");
            }

            Получаем следующий вывод:

            Игорь
            Андрей
            Сергей
            C:\Users\vladk\AppData\Local\Temp\tmpDFC.tmp скопирован в файл C:\Users\vladk\AppData\Local\Temp\tmpDFD.tmp.
            C:\Users\vladk\AppData\Local\Temp\tmpDFC.tmp удален.

            Задание 8.3.2
            Сделайте так, чтобы ваша программа из задания 8.3.1 при каждом запуске добавляла в свой исходный код комментарий о времени последнего запуска. 

            Для этого самостоятельно изучите документацию класса FileInfo и найдите метод, который позволяет добавлять строки в уже существующий файл.

            Получить текущую дату можно с помощью свойства DateTime.Now.

            var fileInfo = new FileInfo(@"C:\source\repos\ConsoleApp8\ConsoleApp8\Program.cs");

            using (StreamWriter sw = fileInfo.AppendText())
            {
                sw.WriteLine($"// Время запуска: {DateTime.Now}");
            }

            using (StreamReader sr = fileInfo.OpenText())
            {
                string str = "";
                while ((str = sr.ReadLine()) != null)
                    Console.WriteLine(str);

            }

            ... текст программы
            // Время запуска: 04.03.2025 23:06:15

            Выше мы рассмотрели основные классы для операций с директориями (Directory и DirectoryInfo)  и файлами (File и FileInfo). 

            Файл может быть как источником данных, так и местом,  куда поток данных направлен. Поток данных в файл называется файловым вводом-выводом. 
            Этот поток в языке C# представлен классом FileStream.

            Но концепция ввода-вывода подразумевает не только файловые потоки. Объектом потока данных может быть область оперативной памяти, буфер 
            или сетевой ресурс. Для каждого из возможных вариантов представлен свой класс, напрямую наследующий от класса Stream.

            Сам класс Stream также располагается в пространстве имен System.IO.  Этот абстрактный класс является базовым для всех видов потоков. 
            Он предоставляет набор членов, которые должны быть реализованы в специализированных потоках. Члены ориентированы на три основные операции: 
            чтение, запись и поиск.

            Что будет реализовано в классе-наследнике, представляющем специализированный поток, зависит от его назначения. 

            Проверить, какие из этих операций поддерживает конкретный тип потока, можно через свойства CanRead, CanWrite и CanSeek.

            Основные типы специализированных потоков:

                FileStream: чтение и запись в файл.
                MemoryStream: представляет резервное хранилище в оперативной памяти, позволяет вести считывание и запись в него.
                NetworkStream: представляет сетевое хранилище. Поддерживает чтение и запись.
                PipeStream: поддерживает чтение из именованных каналов и запись в них и др.

            Несмотря на разные задачи, все типы потоков объединяет общий механизм — все они читают и записывают данные побайтно. Благодаря их реализации 
            в C# вы можете выполнять эти задачи, не обладая знанием специфичных для вашей операционной системы правил.

                Поток — это направленная последовательность байт. Поток ничего не знает об источнике данных.  Им может быть как переменная, 
                так и результат асинхронной операции.
 

            Кроме свойств CanRead, CanWrite и CanSeek, класс предоставляет свойства Position (возвращает текущую позицию в потоке) и Length 
            (возвращает общую длину потока). Эти свойства используются при организации цикла выборки или поиска данных. 

            Важные методы класса Stream:

                Close — закрывает поток, с освобождением всех привязанных к нему ресурсов. Его вызов эквивалентен вызову Dispose.
                Flush — Инициализирует запись всех реализованных в потоке буферов в базовое устройство и очищает их. Если он не реализован, то метод ничего не делает
                Seek — устанавливает текущую позицию внутри потока.
                Read/Write — считывает/записывает количество байт из потока, количество передается в виде параметра и перемещает позицию вперед на количество прочитанных байтов.

            Задание 8.3.3
            В чём основное различие основных классов для работы с файлами: File и FileInfo?

                File предоставляет функционал для операций с файлами, а FileInfo — для получения информации о них
                При использовании File нет необходимости создавать объект класса                                    X
                FileInfo предоставляет более широкие возможности
                Принципиальных различий нет


            Задание 8.3.4
            Ваша программа принимает на вход имена студентов и сохраняет их в текстовый файл. После чего выводит информацию из файла в консоль.

            Какой класс будете использовать в данном случае?

                File, так как он удобнее в использовании — не надо создавать объект класса
                FileInfo, так как здесь многкратная операция файлового ввода вывода, и удобнее будет создать объект один раз, чтобы потом переиспользовать  X
                Нет принципиальной разницы, можно любой
                Ни один из классов не подходит

            Задание 8.3.5
            Выберите, какие из утверждений верны:
            Несколько верных вариантов ответа

                1. Stream — базовый класс для всех видов потоков в C#                               X
                2. Всем потокам доступны две основные операции: чтение и запись
                3. Поток можно закрыть принудительно вызовом соответствующего метода                X
                4. Поток представляет собой данные в текстовом виде
                5. Поток может передавать любые данные, при этом ничего не знает об их источнике    X

            */

            // Получаем все диски
            DriveInfo[] drives = DriveInfo.GetDrives();

            // Фильтруем диски (только фиксированные)
            foreach (var drive in drives.Where(d => d.DriveType == DriveType.Fixed))
            {
                // Выводим информацию о диске
                WriteDriveInfo(drive);

                // Получаем корневую директорию диска
                DirectoryInfo root = drive.RootDirectory;

                // Получаем все папки в корневой директории
                var folders = root.GetDirectories();

                // Выводим информацию о папках
                WriteFolderInfo(folders);

                Console.WriteLine();
                Console.WriteLine();
            }

        }

        public static void WriteDriveInfo(DriveInfo drive)
        {
            Console.WriteLine($"Название: {drive.Name}");
            Console.WriteLine($"Тие: {drive.DriveType}");
            if (drive.IsReady)
            {
                Console.WriteLine($"Объем: {drive.TotalSize}");
                Console.WriteLine($"Свободно: {drive.TotalFreeSpace}");
                Console.WriteLine($"Метка: {drive.VolumeLabel}");
            }

        }

        public static void WriteFolderInfo(DirectoryInfo[] folders)
        {
            Console.WriteLine();
            Console.WriteLine("Папки: ");
            Console.WriteLine();

            foreach (var folder in folders)
            {
                Console.WriteLine(folder.Name + DirectoryExtention.DirSize(folder));
                Console.WriteLine($"Размер директории: {FormatSize(DirectoryExtention.DirSize(folder))}");
            }
        }

        static void GetCatalogs()
        {
            string dirName = @"/"; // Прописываем путь к корневой директории MacOS (для Windows скорее всего тут будет "C:\\")
            if (Directory.Exists(dirName)) // Проверим, что директория существует
            {
                Console.WriteLine("Папки:");
                string[] dirs = Directory.GetDirectories(dirName);  // Получим все директории корневого каталога

                foreach (string d in dirs) // Выведем их все
                    Console.WriteLine(d);

                Console.WriteLine();
                Console.WriteLine("Файлы:");
                string[] files = Directory.GetFiles(dirName);// Получим все файлы корневого каталога

                foreach (string s in files)   // Выведем их все
                    Console.WriteLine(s);
            }
        }

        //Преобразование размера в более читаемый формат (например, КБ, МБ, ГБ):
        static string FormatSize(long bytes)
        {
            string[] sizes = { "B", "KB", "MB", "GB", "TB" };
            int order = 0;
            while (bytes >= 1024 && order < sizes.Length - 1)
            {
                order++;
                bytes /= 1024;
            }
            return $"{bytes:0.##} {sizes[order]}";
        }

    }
}
// Время запуска: 04.03.2025 23:06:15
